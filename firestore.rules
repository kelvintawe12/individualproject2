rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // helper functions
    function isSignedIn() { return request.auth != null; }
    function chatIsParticipant(chatId) {
      return isSignedIn()
        && exists(/databases/$(database)/documents/chats/$(chatId))
        && (request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants);
    }

    // users collection: only the user themselves may create/update/delete their profile
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update, delete: if isSignedIn() && request.auth.uid == userId;
    }

    // listings: any signed-in user may read; only owner may create/update/delete their listing
    match /listings/{listingId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.ownerId;
      allow update, delete: if isSignedIn() && request.auth.uid == resource.data.ownerId;
    }

    // swaps: requester can create, requester/owner can read, owner can update (accept)
    match /swaps/{swapId} {
      allow read: if isSignedIn() && (request.auth.uid == resource.data.requesterId || request.auth.uid == resource.data.ownerId);
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.requesterId;
      allow update: if isSignedIn() && request.auth.uid == resource.data.ownerId;
      allow delete: if false;
    }

    // chats: participants only
    match /chats/{chatId} {
      // chat document should contain a `participants` array of uids
      // Allow reads if the current authenticated user is listed as a participant
      allow read: if isSignedIn() && (request.auth.uid in resource.data.participants);
      // creation of a chat requires the creator to be a participant
      allow create: if isSignedIn() && request.resource.data.participants is list && request.auth.uid in request.resource.data.participants;

      // Allow only chat metadata updates by participants (clients update lastMessage/lastSentAt)
      // This prevents arbitrary updates while allowing the client to update the chat's last message metadata.
      allow update: if isSignedIn()
                    && (request.auth.uid in resource.data.participants)
                    // Ensure only the allowed keys are being changed by the request
                    && request.resource.data.keys().hasOnly(['lastMessage', 'lastSentAt']);

      // Prevent deletion of chats from client SDKs
      allow delete: if false;

      // messages subcollection
      match /messages/{messageId} {
        // allow read if the requester is a participant of the parent chat
        allow read: if isSignedIn() && (request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants);
        // senderId must equal authenticated uid, and sender must be a participant
        allow create: if isSignedIn()
                     && (request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants)
                     && request.auth.uid == request.resource.data.senderId;
        // messages are immutable in this rule set
        allow update, delete: if false;
      }
    }

    // Default: deny everything else
    // chat_requests: allow users to create access requests to ask another user
    // to grant them access to a chat. Creation is permitted when the
    // authenticated uid matches the requesterId field.
    match /chat_requests/{reqId} {
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.requesterId;
      // allow the requester and the target to read their own requests
      allow read: if isSignedIn() && (request.auth.uid == resource.data.requesterId || request.auth.uid == resource.data.targetId);
      allow update, delete: if false;
    }
  }
}
