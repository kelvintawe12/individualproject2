rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper to check authentication
    function isSignedIn() {
      return request.auth != null;
    }

    // USERS: Signed-in users may read; only the user may create/update their profile
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn() && request.auth.uid == userId;
      allow delete: if false;
    }

    // CHAT REQUESTS: allow create/read as needed by the client
    match /chat_requests/{reqId} {
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.requesterId;
      allow read: if isSignedIn() && (request.auth.uid == resource.data.requesterId || request.auth.uid == resource.data.targetId);
      allow update, delete: if false;
    }

    // CHATS and MESSAGES
    match /chats/{chatId} {
      // Creation: signed-in user must be a participant and set themselves as createdBy
      allow create: if isSignedIn()
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.createdBy == request.auth.uid;

      // Read: only participants may read the chat doc
      allow get, list: if isSignedIn() && request.auth.uid in resource.data.participants;

      // Update: two allowed flows
      // 1) participants may update only lastMessage/lastSentAt (we check the
      //    actual written fields so existing doc keys don't block the rule)
      // 2) creator (createdBy) may update metadata fields (name, avatarUrl, participants)
      // Use request.writeFields to determine which fields are being modified
      // during an update call (this avoids the pitfall of request.resource.data
      // containing the entire resulting document).
      allow update: if isSignedIn() && (
        (request.auth.uid in resource.data.participants
          && request.writeFields.hasOnly(['lastMessage','lastSentAt']))
        ||
        (request.auth.uid == resource.data.createdBy
          && request.writeFields.hasAny(['name','avatarUrl','participants','lastMessage','lastSentAt']))
      );

      // Delete: only creator may delete the chat
      allow delete: if isSignedIn() && request.auth.uid == resource.data.createdBy;

      // Messages subcollection
      match /messages/{messageId} {
        // Read: participants only
        allow read: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        // Create: sender must be authenticated and be a participant; senderId must equal auth uid
        allow create: if isSignedIn()
          && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
          && request.resource.data.senderId == request.auth.uid
          && (request.resource.data.text is string || request.resource.data.imageUrl is string);

        // Update/delete messages: only the sender or the chat creator may perform these
        allow update, delete: if isSignedIn() && (
          request.auth.uid == resource.data.senderId ||
          request.auth.uid == get(/databases/$(database)/documents/chats/$(chatId)).data.createdBy
        );
      }
    }

    // LISTINGS and SWAPS: preserve previous restrictions (readable by signed-in users)
    match /listings/{listingId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.ownerId;
      allow update, delete: if isSignedIn() && request.auth.uid == resource.data.ownerId;
    }

    match /swaps/{swapId} {
      allow read: if isSignedIn() && (request.auth.uid == resource.data.requesterId || request.auth.uid == resource.data.ownerId);
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.requesterId;
      allow update: if isSignedIn() && request.auth.uid == resource.data.ownerId;
      allow delete: if false;
    }

    // LIBRARIES: per-user saved listings
    // Document id format used in code: '{userId}_{listingId}'
    match /libraries/{libId} {
      // For single-doc reads ensure the document belongs to the signed-in user
      allow get: if isSignedIn() && resource.data.userId == request.auth.uid;

  // For queries (list) require the client to filter by userId == auth.uid
  // so that the server can verify the query only returns permitted docs.
  // NOTE: some Firestore rules runtimes may not support request.query.where()
  // usage in all contexts; for development we'll allow signed-in users to
  // perform the query and rely on the client to filter by userId==auth.uid.
  // Review and tighten this rule before production.
  allow list: if isSignedIn();

      // Creation: user must be signed-in and userId in the new doc must equal auth.uid
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.userId
        && request.resource.data.listingId is string;

      // Deletion: only the owner may remove their saved entry
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;

      // No arbitrary updates allowed
      allow update: if false;
    }

    // NOTIFICATIONS: users may receive notifications; clients may create
    // notifications (e.g., swap_request) and recipients may read/list them.
    match /notifications/{notifId} {
      // Creation: allow any signed-in user to create a notification document
      // with required fields. We keep validation minimal to allow client-side
      // creation (the app creates notifications on swap/request flows).
      allow create: if isSignedIn()
        && request.resource.data.recipientId is string
        && request.resource.data.type is string
        && request.resource.data.read is bool;

      // Single doc read: allow any signed-in user to read notifications.
      // NOTE: this relaxes the recipient-only restriction for development
      // convenience. For production keep recipient-only reads.
      allow get: if isSignedIn();

      // Queries: allow authenticated users to query notifications. For
      // production you may want to require filtering by recipientId == auth.uid.
      allow list: if isSignedIn();

      // Update: allow recipient to mark as read; restrict updates to 'read' and 'readAt'
      allow update: if isSignedIn()
        && request.auth.uid == resource.data.recipientId
        && request.resource.data.keys().hasOnly(['read','readAt'])
        && request.resource.data.read is bool;

      // Deletion: only recipient may delete their notifications
      allow delete: if isSignedIn() && request.auth.uid == resource.data.recipientId;
    }
  }
}
